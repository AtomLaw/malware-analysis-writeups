#!/usr/bin/env python3
import re
import binascii

#### NOTE: This code is absolutely terrible, and may not be applicable in all environments.
# This is just what I threw together really quick to work with my particular sample; you may
# adjust this script depending on sample variation. This is terrible code.

NOD_FILE = "nod.ps1"
OUT_FILE_444 = "nod_Cli444.exe"
OUT_FILE_555 = "nod_Cli555.dll"

nodDat = ""
with open(NOD_FILE, "r") as f:
    nodDat = f.read()

# Grab Cli444 executable array
byteArr444 = re.findall(r"\$Cli444=\(.*\);[Byte[]", nodDat)[0]
splitBytes444 = byteArr444.split(",")[1:]

# because I'm terrible at regex, my current method gets rid of the first byte
# of the array. Because these are PE's, the first byte will always be 4D.
outDat444 = "4D"
for i in splitBytes444:
        if i.isnumeric():
            newHex = str(hex(int(i))[2:].upper())
            if len(newHex) == 1:   
                newHex = "0" + newHex
            outDat444 += newHex
        else:
            outDat444 += "00"
      
# Grab Cli555 DLL array
byteArr555 = re.findall(r"\$Cli555=\(.*\.replace", nodDat)[0].split(".")[0]
splitBytes555 = byteArr555.split(",")[1:]

# because I'm terrible at regex, my current method gets rid of the first byte
# of the array. Because these are PE's, the first byte will always be 4D.
outDat555 = "4D"
for i in splitBytes555:
    outDat555 += i[3:].upper()

# I'm lazy; last character of the string is a quote, again because of trash
# regex; this just gets rid of it
outDat555 = outDat555[:-1]
binString444 = binascii.unhexlify(outDat444.strip())
with open(OUT_FILE_444, "wb") as f:
    f.write(binString444)
print("nod_Cli444.exe has been Extracted.")
        
binString555 = binascii.unhexlify(outDat555.strip())
with open(OUT_FILE_555, "wb") as f:
    f.write(binString555)
print("nod_Cli555.dll has been Extracted.")
    
